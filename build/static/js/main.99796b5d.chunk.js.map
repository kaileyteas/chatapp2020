{"version":3,"sources":["db.js","namePicker.js","App.js","serviceWorker.js","index.js"],"names":["store","coll","useDB","room","useState","messages","setMessages","useEffect","collection","where","onSnapshot","snap","docChanges","forEach","c","m","id","doc","type","data","current","msgs","sort","a","b","ts","seconds","filter","db","msg","add","delete","firebase","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","NamePicker","props","name","setName","showName","setShowName","inputEl","useRef","save","focus","onSave","localStorage","setItem","n","getItem","className","value","ref","style","display","onChange","e","target","onKeyPress","key","onClick","Room","match","params","showCamera","setShowCamera","takePicture","img","async","imgID","Math","random","toString","substring","storageRef","child","putString","send","Date","src","map","i","Message","TextInput","onSend","text","from","console","log","alt","setText","left","right","height","width","placeholder","disabled","App","window","location","pathname","length","path","component","Boolean","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.99796b5d.chunk.js","sourcesContent":["import {useState, useEffect} from 'react'\nimport * as firebase from \"firebase/app\"\nimport \"firebase/firestore\"\nimport \"firebase/storage\"\n\nlet store\nconst coll = 'messages'\n\nfunction useDB(room) {\n    const [messages, setMessages] = useState([])\n    function add(m) {\n        setMessages(current => {\n            const msgs = [m, ...current]\n            msgs.sort((a,b)=> b.ts.seconds - a.ts.seconds)\n            return msgs\n        })\n    }\n    function remove(id) {\n        setMessages(current=> current.filter(m=> m.id!==id))\n    }\n\n    useEffect(() => {\n        store.collection(coll)\n        .where('room','==',room)\n        .onSnapshot(snap=> snap.docChanges().forEach(c=> {\n            const {doc, type} = c\n            if (type==='added') add({...doc.data(),id:doc.id})\n            if (type==='removed') remove(doc.id)\n        }))\n    }, [])\n    return messages\n}\n\nconst db = {}\ndb.send = function(msg) {\n    return store.collection(coll).add(msg)\n}\ndb.delete = function(id) {\n    return store.collection(coll).doc(id).delete()\n}\n\nexport { db, useDB }\n\nconst firebaseConfig = {\n    apiKey: \"AIzaSyC37_Lo0EODqLfGtxg7v1FDHbgHUSBa0no\",\n    authDomain: \"chatroom-e34eb.firebaseapp.com\",\n    databaseURL: \"https://chatroom-e34eb.firebaseio.com\",\n    projectId: \"chatroom-e34eb\",\n    storageBucket: \"chatroom-e34eb.appspot.com\",\n    messagingSenderId: \"86918280767\",\n    appId: \"1:86918280767:web:8cd5ba999c6a251e76aa8a\"\n  };\n\nfirebase.initializeApp(firebaseConfig)\nstore = firebase.firestore()","import React, {useState, useRef, useEffect} from 'react'\nimport { FiEdit, FiSave } from 'react-icons/fi'\n\nfunction NamePicker(props) {\n  const [name, setName] = useState('')\n  const [showName, setShowName] = useState(false)\n  const inputEl = useRef(null)\n\n  function save(){\n    inputEl.current.focus()\n    if(name && !showName) {\n      props.onSave(name)\n      localStorage.setItem('name',name)\n    }\n    setShowName(!showName)\n  }\n\n  useEffect(()=>{\n    const n = localStorage.getItem('name')\n    if(n) {\n      setName(n)\n      save() \n    }\n  }, [])\n\n  return <div className=\"edit-username\">\n    <input value={name} ref={inputEl}\n      className=\"name-input\"\n      style={{display: showName ? 'none' : 'flex'}}\n      onChange={e=> setName(e.target.value)}\n      onKeyPress={e=> {\n        if(e.key==='Enter') save()\n      }}\n    />\n\n    {showName && <div className=\"username\">{name}</div>}\n\n    <button onClick={save} className=\"name-button\">\n      {showName ? <FiEdit /> : <FiSave />}\n    </button>\n  </div>\n}\n\nexport default NamePicker","import React, {useState, useEffect} from 'react';\nimport './App.css';\nimport { db, useDB } from './db'\nimport NamePicker from './namePicker'\nimport { BrowserRouter, Route } from 'react-router-dom'\nimport { FiSend, FiCamera } from 'react-icons/fi'\nimport Camera from 'react-snap-pic'\nimport * as firebase from \"firebase/app\"\nimport \"firebase/firestore\"\nimport \"firebase/storage\"\nimport \"./media.css\"\n\nfunction App(){\n  {/* This redirects the user to a localhost page called 'home' */}\n  useEffect(()=>{\n    const {pathname} = window.location\n    if(pathname.length<2) window.location.pathname='home'\n  },[])\n\n  return <BrowserRouter>\n    <Route path=\"/:room\" component={Room}/>\n  </BrowserRouter>\n}\n\nfunction Room(props) {\n  // in usestate, we set messages to an empty array to show messages\n  // while setMesages is a function\n  // const [messages, setMessages] = useState([])\n  const {room} = props.match.params\n  const [name, setName] = useState('')\n  const [showCamera, setShowCamera] = useState(false)\n  const messages = useDB(room)\n\n  /** This is a asynchronous method, meaning that it will wait until prompted\n   *  You can use the wait method with async functions, but without declaring async,\n   *  it will not work.\n   */\n  async function takePicture(img) {\n    setShowCamera(false)\n    const imgID = Math.random().toString(36).substring(7)\n    var storageRef = firebase.storage().ref()\n    var ref = storageRef.child(imgID + '.jpg')\n    await ref.putString(img, 'data_url')\n    db.send({ img: imgID, name, ts: new Date(), room })\n  }\n\n  return <main>\n    \n    {showCamera && <Camera takePicture={takePicture} />}\n\n    <header className=\"header\"> \n      <div className=\"logo-wrap\">\n        <img src=\"http://assets.stickpng.com/thumbs/580b57fcd9996e24bc43c541.png\" \n        className=\"logo\"\n        />\n      </div>\n      Fresh memes\n      <NamePicker onSave = {setName}/>\n    </header>\n    \n    {/* returning HTML for a new message that is being sent to the chat */}\n    <div className=\"messages\">\n      {messages.map((m,i)=> <Message key={i} m={m} name={name}/>)}\n    </div>\n\n    {/* messages -- the text we send to textinput*/}\n    {/* the ... implies that we will append all new messages to the beginning of the list */}\n    <TextInput \n      showCamera={()=>setShowCamera(true)}\n      onSend={(text)=>{\n        db.send({\n          text, name, ts: new Date(), room\n      })\n    }}/>\n\n  </main>\n}\n\nconst bucket = 'https://firebasestorage.googleapis.com/v0/b/chatroom-e34eb.appspot.com/o/'\nconst suffix = '.jpg?alt=media'\n\nfunction Message({m, name}){\n  return <div className=\"message-wrap\"\n    from={m.name===name?'me':'you'}\n    onClick={()=>console.log(m)}>\n    <div className=\"message\">\n      <div className=\"msg-name\">{m.name}</div>\n      <div className=\"msg-text\">{m.text}\n      {m.img && <img src={bucket + m.img + suffix} alt=\"pic\"/>}</div>\n    </div>\n  </div>\n}\n\nfunction TextInput(props){\n  const [text, setText] = useState('')\n\n  return <div className=\"text-input-wrap\">\n    <button onClick={props.showCamera}\n      style={{left:10, right:'auto'}}>\n      <FiCamera style={{height:15, width:15}} />\n    </button>\n    <input \n      value={text}\n      className=\"text-input\"\n      placeholder=\"Enter text\"\n      onChange={e=> setText(e.target.value)}\n      onKeyPress={e=> {\n        if(e.key==='Enter') {\n          if(text) props.onSend(text)\n          setText('')\n        }\n      }}\n    />\n    <button onClick={()=> {\n      props.onSend(text)\n      setText('')\n      }}\n      className=\"button\"\n      disabled={!text}\n    >\n    ↑\n    </button>\n  </div>\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}